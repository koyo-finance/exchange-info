"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

type Account {
	address: Bytes!

	"  "
	gaugeWeightVotes(
		first: Int = 100
		orderBy: GaugeWeightVote_orderBy
		orderDirection: OrderDirection
		skip: Int = 0
		where: GaugeWeightVote_filter
	): [GaugeWeightVote!]

	"""
	 Liquidity gauges this account contributed to
	"""
	gauges(
		first: Int = 100
		orderBy: GaugeLiquidity_orderBy
		orderDirection: OrderDirection
		skip: Int = 0
		where: GaugeLiquidity_filter
	): [GaugeLiquidity!]
	id: ID!
}

input Account_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	address: Bytes
	address_contains: Bytes
	address_in: [Bytes!]
	address_not: Bytes
	address_not_contains: Bytes
	address_not_in: [Bytes!]
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
}

enum Account_orderBy {
	address
	gaugeWeightVotes
	gauges
	id
}

scalar BigDecimal

scalar BigInt

type Block {
	author: String
	difficulty: BigInt
	gasLimit: BigInt
	gasUsed: BigInt
	id: ID!
	number: BigInt!
	parentHash: String
	receiptsRoot: String
	size: BigInt
	stateRoot: String
	timestamp: BigInt!
	totalDifficulty: BigInt
	transactionsRoot: String
	unclesHash: String
}

input BlockChangedFilter {
	number_gte: Int!
}

input Block_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	author: String
	author_contains: String
	author_contains_nocase: String
	author_ends_with: String
	author_ends_with_nocase: String
	author_gt: String
	author_gte: String
	author_in: [String!]
	author_lt: String
	author_lte: String
	author_not: String
	author_not_contains: String
	author_not_contains_nocase: String
	author_not_ends_with: String
	author_not_ends_with_nocase: String
	author_not_in: [String!]
	author_not_starts_with: String
	author_not_starts_with_nocase: String
	author_starts_with: String
	author_starts_with_nocase: String
	difficulty: BigInt
	difficulty_gt: BigInt
	difficulty_gte: BigInt
	difficulty_in: [BigInt!]
	difficulty_lt: BigInt
	difficulty_lte: BigInt
	difficulty_not: BigInt
	difficulty_not_in: [BigInt!]
	gasLimit: BigInt
	gasLimit_gt: BigInt
	gasLimit_gte: BigInt
	gasLimit_in: [BigInt!]
	gasLimit_lt: BigInt
	gasLimit_lte: BigInt
	gasLimit_not: BigInt
	gasLimit_not_in: [BigInt!]
	gasUsed: BigInt
	gasUsed_gt: BigInt
	gasUsed_gte: BigInt
	gasUsed_in: [BigInt!]
	gasUsed_lt: BigInt
	gasUsed_lte: BigInt
	gasUsed_not: BigInt
	gasUsed_not_in: [BigInt!]
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	number: BigInt
	number_gt: BigInt
	number_gte: BigInt
	number_in: [BigInt!]
	number_lt: BigInt
	number_lte: BigInt
	number_not: BigInt
	number_not_in: [BigInt!]
	parentHash: String
	parentHash_contains: String
	parentHash_contains_nocase: String
	parentHash_ends_with: String
	parentHash_ends_with_nocase: String
	parentHash_gt: String
	parentHash_gte: String
	parentHash_in: [String!]
	parentHash_lt: String
	parentHash_lte: String
	parentHash_not: String
	parentHash_not_contains: String
	parentHash_not_contains_nocase: String
	parentHash_not_ends_with: String
	parentHash_not_ends_with_nocase: String
	parentHash_not_in: [String!]
	parentHash_not_starts_with: String
	parentHash_not_starts_with_nocase: String
	parentHash_starts_with: String
	parentHash_starts_with_nocase: String
	receiptsRoot: String
	receiptsRoot_contains: String
	receiptsRoot_contains_nocase: String
	receiptsRoot_ends_with: String
	receiptsRoot_ends_with_nocase: String
	receiptsRoot_gt: String
	receiptsRoot_gte: String
	receiptsRoot_in: [String!]
	receiptsRoot_lt: String
	receiptsRoot_lte: String
	receiptsRoot_not: String
	receiptsRoot_not_contains: String
	receiptsRoot_not_contains_nocase: String
	receiptsRoot_not_ends_with: String
	receiptsRoot_not_ends_with_nocase: String
	receiptsRoot_not_in: [String!]
	receiptsRoot_not_starts_with: String
	receiptsRoot_not_starts_with_nocase: String
	receiptsRoot_starts_with: String
	receiptsRoot_starts_with_nocase: String
	size: BigInt
	size_gt: BigInt
	size_gte: BigInt
	size_in: [BigInt!]
	size_lt: BigInt
	size_lte: BigInt
	size_not: BigInt
	size_not_in: [BigInt!]
	stateRoot: String
	stateRoot_contains: String
	stateRoot_contains_nocase: String
	stateRoot_ends_with: String
	stateRoot_ends_with_nocase: String
	stateRoot_gt: String
	stateRoot_gte: String
	stateRoot_in: [String!]
	stateRoot_lt: String
	stateRoot_lte: String
	stateRoot_not: String
	stateRoot_not_contains: String
	stateRoot_not_contains_nocase: String
	stateRoot_not_ends_with: String
	stateRoot_not_ends_with_nocase: String
	stateRoot_not_in: [String!]
	stateRoot_not_starts_with: String
	stateRoot_not_starts_with_nocase: String
	stateRoot_starts_with: String
	stateRoot_starts_with_nocase: String
	timestamp: BigInt
	timestamp_gt: BigInt
	timestamp_gte: BigInt
	timestamp_in: [BigInt!]
	timestamp_lt: BigInt
	timestamp_lte: BigInt
	timestamp_not: BigInt
	timestamp_not_in: [BigInt!]
	totalDifficulty: BigInt
	totalDifficulty_gt: BigInt
	totalDifficulty_gte: BigInt
	totalDifficulty_in: [BigInt!]
	totalDifficulty_lt: BigInt
	totalDifficulty_lte: BigInt
	totalDifficulty_not: BigInt
	totalDifficulty_not_in: [BigInt!]
	transactionsRoot: String
	transactionsRoot_contains: String
	transactionsRoot_contains_nocase: String
	transactionsRoot_ends_with: String
	transactionsRoot_ends_with_nocase: String
	transactionsRoot_gt: String
	transactionsRoot_gte: String
	transactionsRoot_in: [String!]
	transactionsRoot_lt: String
	transactionsRoot_lte: String
	transactionsRoot_not: String
	transactionsRoot_not_contains: String
	transactionsRoot_not_contains_nocase: String
	transactionsRoot_not_ends_with: String
	transactionsRoot_not_ends_with_nocase: String
	transactionsRoot_not_in: [String!]
	transactionsRoot_not_starts_with: String
	transactionsRoot_not_starts_with_nocase: String
	transactionsRoot_starts_with: String
	transactionsRoot_starts_with_nocase: String
	unclesHash: String
	unclesHash_contains: String
	unclesHash_contains_nocase: String
	unclesHash_ends_with: String
	unclesHash_ends_with_nocase: String
	unclesHash_gt: String
	unclesHash_gte: String
	unclesHash_in: [String!]
	unclesHash_lt: String
	unclesHash_lte: String
	unclesHash_not: String
	unclesHash_not_contains: String
	unclesHash_not_contains_nocase: String
	unclesHash_not_ends_with: String
	unclesHash_not_ends_with_nocase: String
	unclesHash_not_in: [String!]
	unclesHash_not_starts_with: String
	unclesHash_not_starts_with_nocase: String
	unclesHash_starts_with: String
	unclesHash_starts_with_nocase: String
}

input Block_height {
	hash: Bytes
	number: Int
	number_gte: Int
}

enum Block_orderBy {
	author
	difficulty
	gasLimit
	gasUsed
	id
	number
	parentHash
	receiptsRoot
	size
	stateRoot
	timestamp
	totalDifficulty
	transactionsRoot
	unclesHash
}

scalar Bytes

type Gauge {
	address: Bytes!
	created: BigInt!
	createdAtBlock: BigInt!
	createdAtTransaction: Bytes!
	id: ID!
	name: String!
	symbol: String!
	type: GaugeType!
	weightVotes(
		first: Int = 100
		orderBy: GaugeWeightVote_orderBy
		orderDirection: OrderDirection
		skip: Int = 0
		where: GaugeWeightVote_filter
	): [GaugeWeightVote!]
	weights(first: Int = 100, orderBy: GaugeWeight_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: GaugeWeight_filter): [GaugeWeight!]
}

type GaugeDeposit {
	gauge: Gauge!
	id: ID!
	provider: Account!
	value: BigDecimal!
}

input GaugeDeposit_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	gauge: String
	gauge_contains: String
	gauge_contains_nocase: String
	gauge_ends_with: String
	gauge_ends_with_nocase: String
	gauge_gt: String
	gauge_gte: String
	gauge_in: [String!]
	gauge_lt: String
	gauge_lte: String
	gauge_not: String
	gauge_not_contains: String
	gauge_not_contains_nocase: String
	gauge_not_ends_with: String
	gauge_not_ends_with_nocase: String
	gauge_not_in: [String!]
	gauge_not_starts_with: String
	gauge_not_starts_with_nocase: String
	gauge_starts_with: String
	gauge_starts_with_nocase: String
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	provider: String
	provider_contains: String
	provider_contains_nocase: String
	provider_ends_with: String
	provider_ends_with_nocase: String
	provider_gt: String
	provider_gte: String
	provider_in: [String!]
	provider_lt: String
	provider_lte: String
	provider_not: String
	provider_not_contains: String
	provider_not_contains_nocase: String
	provider_not_ends_with: String
	provider_not_ends_with_nocase: String
	provider_not_in: [String!]
	provider_not_starts_with: String
	provider_not_starts_with_nocase: String
	provider_starts_with: String
	provider_starts_with_nocase: String
	value: BigDecimal
	value_gt: BigDecimal
	value_gte: BigDecimal
	value_in: [BigDecimal!]
	value_lt: BigDecimal
	value_lte: BigDecimal
	value_not: BigDecimal
	value_not_in: [BigDecimal!]
}

enum GaugeDeposit_orderBy {
	gauge
	id
	provider
	value
}

type GaugeLiquidity {
	block: BigInt!
	gauge: Gauge!
	id: ID!
	originalBalance: BigInt!
	originalSupply: BigInt!
	timestamp: BigInt!
	transaction: Bytes!
	user: Account!
	workingBalance: BigInt!
	workingSupply: BigInt!
}

input GaugeLiquidity_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	block: BigInt
	block_gt: BigInt
	block_gte: BigInt
	block_in: [BigInt!]
	block_lt: BigInt
	block_lte: BigInt
	block_not: BigInt
	block_not_in: [BigInt!]
	gauge: String
	gauge_contains: String
	gauge_contains_nocase: String
	gauge_ends_with: String
	gauge_ends_with_nocase: String
	gauge_gt: String
	gauge_gte: String
	gauge_in: [String!]
	gauge_lt: String
	gauge_lte: String
	gauge_not: String
	gauge_not_contains: String
	gauge_not_contains_nocase: String
	gauge_not_ends_with: String
	gauge_not_ends_with_nocase: String
	gauge_not_in: [String!]
	gauge_not_starts_with: String
	gauge_not_starts_with_nocase: String
	gauge_starts_with: String
	gauge_starts_with_nocase: String
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	originalBalance: BigInt
	originalBalance_gt: BigInt
	originalBalance_gte: BigInt
	originalBalance_in: [BigInt!]
	originalBalance_lt: BigInt
	originalBalance_lte: BigInt
	originalBalance_not: BigInt
	originalBalance_not_in: [BigInt!]
	originalSupply: BigInt
	originalSupply_gt: BigInt
	originalSupply_gte: BigInt
	originalSupply_in: [BigInt!]
	originalSupply_lt: BigInt
	originalSupply_lte: BigInt
	originalSupply_not: BigInt
	originalSupply_not_in: [BigInt!]
	timestamp: BigInt
	timestamp_gt: BigInt
	timestamp_gte: BigInt
	timestamp_in: [BigInt!]
	timestamp_lt: BigInt
	timestamp_lte: BigInt
	timestamp_not: BigInt
	timestamp_not_in: [BigInt!]
	transaction: Bytes
	transaction_contains: Bytes
	transaction_in: [Bytes!]
	transaction_not: Bytes
	transaction_not_contains: Bytes
	transaction_not_in: [Bytes!]
	user: String
	user_contains: String
	user_contains_nocase: String
	user_ends_with: String
	user_ends_with_nocase: String
	user_gt: String
	user_gte: String
	user_in: [String!]
	user_lt: String
	user_lte: String
	user_not: String
	user_not_contains: String
	user_not_contains_nocase: String
	user_not_ends_with: String
	user_not_ends_with_nocase: String
	user_not_in: [String!]
	user_not_starts_with: String
	user_not_starts_with_nocase: String
	user_starts_with: String
	user_starts_with_nocase: String
	workingBalance: BigInt
	workingBalance_gt: BigInt
	workingBalance_gte: BigInt
	workingBalance_in: [BigInt!]
	workingBalance_lt: BigInt
	workingBalance_lte: BigInt
	workingBalance_not: BigInt
	workingBalance_not_in: [BigInt!]
	workingSupply: BigInt
	workingSupply_gt: BigInt
	workingSupply_gte: BigInt
	workingSupply_in: [BigInt!]
	workingSupply_lt: BigInt
	workingSupply_lte: BigInt
	workingSupply_not: BigInt
	workingSupply_not_in: [BigInt!]
}

enum GaugeLiquidity_orderBy {
	block
	gauge
	id
	originalBalance
	originalSupply
	timestamp
	transaction
	user
	workingBalance
	workingSupply
}

type GaugeTotalWeight {
	id: ID!
	time: BigInt!
	weight: BigDecimal!
}

input GaugeTotalWeight_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	time: BigInt
	time_gt: BigInt
	time_gte: BigInt
	time_in: [BigInt!]
	time_lt: BigInt
	time_lte: BigInt
	time_not: BigInt
	time_not_in: [BigInt!]
	weight: BigDecimal
	weight_gt: BigDecimal
	weight_gte: BigDecimal
	weight_in: [BigDecimal!]
	weight_lt: BigDecimal
	weight_lte: BigDecimal
	weight_not: BigDecimal
	weight_not_in: [BigDecimal!]
}

enum GaugeTotalWeight_orderBy {
	id
	time
	weight
}

type GaugeType {
	gaugeCount: BigInt!
	gauges(first: Int = 100, orderBy: Gauge_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Gauge_filter): [Gauge!]
	id: ID!
	name: String!
	weights(
		first: Int = 100
		orderBy: GaugeTypeWeight_orderBy
		orderDirection: OrderDirection
		skip: Int = 0
		where: GaugeTypeWeight_filter
	): [GaugeTypeWeight!]
}

type GaugeTypeWeight {
	id: ID!
	time: BigInt!
	type: GaugeType!
	weight: BigDecimal!
}

input GaugeTypeWeight_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	time: BigInt
	time_gt: BigInt
	time_gte: BigInt
	time_in: [BigInt!]
	time_lt: BigInt
	time_lte: BigInt
	time_not: BigInt
	time_not_in: [BigInt!]
	type: String
	type_contains: String
	type_contains_nocase: String
	type_ends_with: String
	type_ends_with_nocase: String
	type_gt: String
	type_gte: String
	type_in: [String!]
	type_lt: String
	type_lte: String
	type_not: String
	type_not_contains: String
	type_not_contains_nocase: String
	type_not_ends_with: String
	type_not_ends_with_nocase: String
	type_not_in: [String!]
	type_not_starts_with: String
	type_not_starts_with_nocase: String
	type_starts_with: String
	type_starts_with_nocase: String
	weight: BigDecimal
	weight_gt: BigDecimal
	weight_gte: BigDecimal
	weight_in: [BigDecimal!]
	weight_lt: BigDecimal
	weight_lte: BigDecimal
	weight_not: BigDecimal
	weight_not_in: [BigDecimal!]
}

enum GaugeTypeWeight_orderBy {
	id
	time
	type
	weight
}

input GaugeType_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	gaugeCount: BigInt
	gaugeCount_gt: BigInt
	gaugeCount_gte: BigInt
	gaugeCount_in: [BigInt!]
	gaugeCount_lt: BigInt
	gaugeCount_lte: BigInt
	gaugeCount_not: BigInt
	gaugeCount_not_in: [BigInt!]
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	name: String
	name_contains: String
	name_contains_nocase: String
	name_ends_with: String
	name_ends_with_nocase: String
	name_gt: String
	name_gte: String
	name_in: [String!]
	name_lt: String
	name_lte: String
	name_not: String
	name_not_contains: String
	name_not_contains_nocase: String
	name_not_ends_with: String
	name_not_ends_with_nocase: String
	name_not_in: [String!]
	name_not_starts_with: String
	name_not_starts_with_nocase: String
	name_starts_with: String
	name_starts_with_nocase: String
}

enum GaugeType_orderBy {
	gaugeCount
	gauges
	id
	name
	weights
}

type GaugeWeight {
	gauge: Gauge!
	id: ID!
	time: BigInt!
	weight: BigDecimal!
}

type GaugeWeightVote {
	gauge: Gauge!
	id: ID!
	time: BigInt!
	user: Account!
	weight: BigDecimal!
}

input GaugeWeightVote_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	gauge: String
	gauge_contains: String
	gauge_contains_nocase: String
	gauge_ends_with: String
	gauge_ends_with_nocase: String
	gauge_gt: String
	gauge_gte: String
	gauge_in: [String!]
	gauge_lt: String
	gauge_lte: String
	gauge_not: String
	gauge_not_contains: String
	gauge_not_contains_nocase: String
	gauge_not_ends_with: String
	gauge_not_ends_with_nocase: String
	gauge_not_in: [String!]
	gauge_not_starts_with: String
	gauge_not_starts_with_nocase: String
	gauge_starts_with: String
	gauge_starts_with_nocase: String
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	time: BigInt
	time_gt: BigInt
	time_gte: BigInt
	time_in: [BigInt!]
	time_lt: BigInt
	time_lte: BigInt
	time_not: BigInt
	time_not_in: [BigInt!]
	user: String
	user_contains: String
	user_contains_nocase: String
	user_ends_with: String
	user_ends_with_nocase: String
	user_gt: String
	user_gte: String
	user_in: [String!]
	user_lt: String
	user_lte: String
	user_not: String
	user_not_contains: String
	user_not_contains_nocase: String
	user_not_ends_with: String
	user_not_ends_with_nocase: String
	user_not_in: [String!]
	user_not_starts_with: String
	user_not_starts_with_nocase: String
	user_starts_with: String
	user_starts_with_nocase: String
	weight: BigDecimal
	weight_gt: BigDecimal
	weight_gte: BigDecimal
	weight_in: [BigDecimal!]
	weight_lt: BigDecimal
	weight_lte: BigDecimal
	weight_not: BigDecimal
	weight_not_in: [BigDecimal!]
}

enum GaugeWeightVote_orderBy {
	gauge
	id
	time
	user
	weight
}

input GaugeWeight_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	gauge: String
	gauge_contains: String
	gauge_contains_nocase: String
	gauge_ends_with: String
	gauge_ends_with_nocase: String
	gauge_gt: String
	gauge_gte: String
	gauge_in: [String!]
	gauge_lt: String
	gauge_lte: String
	gauge_not: String
	gauge_not_contains: String
	gauge_not_contains_nocase: String
	gauge_not_ends_with: String
	gauge_not_ends_with_nocase: String
	gauge_not_in: [String!]
	gauge_not_starts_with: String
	gauge_not_starts_with_nocase: String
	gauge_starts_with: String
	gauge_starts_with_nocase: String
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	time: BigInt
	time_gt: BigInt
	time_gte: BigInt
	time_in: [BigInt!]
	time_lt: BigInt
	time_lte: BigInt
	time_not: BigInt
	time_not_in: [BigInt!]
	weight: BigDecimal
	weight_gt: BigDecimal
	weight_gte: BigDecimal
	weight_in: [BigDecimal!]
	weight_lt: BigDecimal
	weight_lte: BigDecimal
	weight_not: BigDecimal
	weight_not_in: [BigDecimal!]
}

enum GaugeWeight_orderBy {
	gauge
	id
	time
	weight
}

type GaugeWithdraw {
	gauge: Gauge!
	id: ID!
	provider: Account!
	value: BigDecimal!
}

input GaugeWithdraw_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	gauge: String
	gauge_contains: String
	gauge_contains_nocase: String
	gauge_ends_with: String
	gauge_ends_with_nocase: String
	gauge_gt: String
	gauge_gte: String
	gauge_in: [String!]
	gauge_lt: String
	gauge_lte: String
	gauge_not: String
	gauge_not_contains: String
	gauge_not_contains_nocase: String
	gauge_not_ends_with: String
	gauge_not_ends_with_nocase: String
	gauge_not_in: [String!]
	gauge_not_starts_with: String
	gauge_not_starts_with_nocase: String
	gauge_starts_with: String
	gauge_starts_with_nocase: String
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	provider: String
	provider_contains: String
	provider_contains_nocase: String
	provider_ends_with: String
	provider_ends_with_nocase: String
	provider_gt: String
	provider_gte: String
	provider_in: [String!]
	provider_lt: String
	provider_lte: String
	provider_not: String
	provider_not_contains: String
	provider_not_contains_nocase: String
	provider_not_ends_with: String
	provider_not_ends_with_nocase: String
	provider_not_in: [String!]
	provider_not_starts_with: String
	provider_not_starts_with_nocase: String
	provider_starts_with: String
	provider_starts_with_nocase: String
	value: BigDecimal
	value_gt: BigDecimal
	value_gte: BigDecimal
	value_in: [BigDecimal!]
	value_lt: BigDecimal
	value_lte: BigDecimal
	value_not: BigDecimal
	value_not_in: [BigDecimal!]
}

enum GaugeWithdraw_orderBy {
	gauge
	id
	provider
	value
}

input Gauge_filter {
	"""
	Filter for the block changed event.
	"""
	_change_block: BlockChangedFilter
	address: Bytes
	address_contains: Bytes
	address_in: [Bytes!]
	address_not: Bytes
	address_not_contains: Bytes
	address_not_in: [Bytes!]
	created: BigInt
	createdAtBlock: BigInt
	createdAtBlock_gt: BigInt
	createdAtBlock_gte: BigInt
	createdAtBlock_in: [BigInt!]
	createdAtBlock_lt: BigInt
	createdAtBlock_lte: BigInt
	createdAtBlock_not: BigInt
	createdAtBlock_not_in: [BigInt!]
	createdAtTransaction: Bytes
	createdAtTransaction_contains: Bytes
	createdAtTransaction_in: [Bytes!]
	createdAtTransaction_not: Bytes
	createdAtTransaction_not_contains: Bytes
	createdAtTransaction_not_in: [Bytes!]
	created_gt: BigInt
	created_gte: BigInt
	created_in: [BigInt!]
	created_lt: BigInt
	created_lte: BigInt
	created_not: BigInt
	created_not_in: [BigInt!]
	id: ID
	id_gt: ID
	id_gte: ID
	id_in: [ID!]
	id_lt: ID
	id_lte: ID
	id_not: ID
	id_not_in: [ID!]
	name: String
	name_contains: String
	name_contains_nocase: String
	name_ends_with: String
	name_ends_with_nocase: String
	name_gt: String
	name_gte: String
	name_in: [String!]
	name_lt: String
	name_lte: String
	name_not: String
	name_not_contains: String
	name_not_contains_nocase: String
	name_not_ends_with: String
	name_not_ends_with_nocase: String
	name_not_in: [String!]
	name_not_starts_with: String
	name_not_starts_with_nocase: String
	name_starts_with: String
	name_starts_with_nocase: String
	symbol: String
	symbol_contains: String
	symbol_contains_nocase: String
	symbol_ends_with: String
	symbol_ends_with_nocase: String
	symbol_gt: String
	symbol_gte: String
	symbol_in: [String!]
	symbol_lt: String
	symbol_lte: String
	symbol_not: String
	symbol_not_contains: String
	symbol_not_contains_nocase: String
	symbol_not_ends_with: String
	symbol_not_ends_with_nocase: String
	symbol_not_in: [String!]
	symbol_not_starts_with: String
	symbol_not_starts_with_nocase: String
	symbol_starts_with: String
	symbol_starts_with_nocase: String
	type: String
	type_contains: String
	type_contains_nocase: String
	type_ends_with: String
	type_ends_with_nocase: String
	type_gt: String
	type_gte: String
	type_in: [String!]
	type_lt: String
	type_lte: String
	type_not: String
	type_not_contains: String
	type_not_contains_nocase: String
	type_not_ends_with: String
	type_not_ends_with_nocase: String
	type_not_in: [String!]
	type_not_starts_with: String
	type_not_starts_with_nocase: String
	type_starts_with: String
	type_starts_with_nocase: String
}

enum Gauge_orderBy {
	address
	created
	createdAtBlock
	createdAtTransaction
	id
	name
	symbol
	type
	weightVotes
	weights
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
	asc
	desc
}

type Query {
	"""
	Access to subgraph metadata
	"""
	_meta(block: Block_height): _Meta_
	account(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): Account
	accounts(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: Account_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: Account_filter
	): [Account!]!
	block(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): Block
	blocks(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: Block_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: Block_filter
	): [Block!]!
	gauge(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): Gauge
	gaugeDeposit(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeDeposit
	gaugeDeposits(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeDeposit_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeDeposit_filter
	): [GaugeDeposit!]!
	gaugeLiquidities(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeLiquidity_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeLiquidity_filter
	): [GaugeLiquidity!]!
	gaugeLiquidity(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeLiquidity
	gaugeTotalWeight(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeTotalWeight
	gaugeTotalWeights(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeTotalWeight_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeTotalWeight_filter
	): [GaugeTotalWeight!]!
	gaugeType(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeType
	gaugeTypeWeight(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeTypeWeight
	gaugeTypeWeights(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeTypeWeight_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeTypeWeight_filter
	): [GaugeTypeWeight!]!
	gaugeTypes(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeType_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeType_filter
	): [GaugeType!]!
	gaugeWeight(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeWeight
	gaugeWeightVote(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeWeightVote
	gaugeWeightVotes(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeWeightVote_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeWeightVote_filter
	): [GaugeWeightVote!]!
	gaugeWeights(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeWeight_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeWeight_filter
	): [GaugeWeight!]!
	gaugeWithdraw(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeWithdraw
	gaugeWithdraws(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeWithdraw_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeWithdraw_filter
	): [GaugeWithdraw!]!
	gauges(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: Gauge_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: Gauge_filter
	): [Gauge!]!
}

type Subscription {
	"""
	Access to subgraph metadata
	"""
	_meta(block: Block_height): _Meta_
	account(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): Account
	accounts(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: Account_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: Account_filter
	): [Account!]!
	block(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): Block
	blocks(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: Block_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: Block_filter
	): [Block!]!
	gauge(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): Gauge
	gaugeDeposit(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeDeposit
	gaugeDeposits(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeDeposit_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeDeposit_filter
	): [GaugeDeposit!]!
	gaugeLiquidities(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeLiquidity_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeLiquidity_filter
	): [GaugeLiquidity!]!
	gaugeLiquidity(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeLiquidity
	gaugeTotalWeight(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeTotalWeight
	gaugeTotalWeights(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeTotalWeight_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeTotalWeight_filter
	): [GaugeTotalWeight!]!
	gaugeType(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeType
	gaugeTypeWeight(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeTypeWeight
	gaugeTypeWeights(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeTypeWeight_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeTypeWeight_filter
	): [GaugeTypeWeight!]!
	gaugeTypes(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeType_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeType_filter
	): [GaugeType!]!
	gaugeWeight(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeWeight
	gaugeWeightVote(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeWeightVote
	gaugeWeightVotes(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeWeightVote_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeWeightVote_filter
	): [GaugeWeightVote!]!
	gaugeWeights(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeWeight_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeWeight_filter
	): [GaugeWeight!]!
	gaugeWithdraw(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		id: ID!

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
	): GaugeWithdraw
	gaugeWithdraws(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: GaugeWithdraw_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: GaugeWithdraw_filter
	): [GaugeWithdraw!]!
	gauges(
		"""
		The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
		"""
		block: Block_height
		first: Int = 100
		orderBy: Gauge_orderBy
		orderDirection: OrderDirection
		skip: Int = 0

		"""
		Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
		"""
		subgraphError: _SubgraphErrorPolicy_! = deny
		where: Gauge_filter
	): [Gauge!]!
}

type _Block_ {
	"""
	The hash of the block
	"""
	hash: Bytes

	"""
	The block number
	"""
	number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
	"Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
	block: _Block_!

	"""
	The deployment ID
	"""
	deployment: String!

	"""
	If `true`, the subgraph encountered indexing errors at some past block
	"""
	hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
	"""
	Data will be returned even if the subgraph has indexing errors
	"""
	allow

	"""
	If the subgraph has indexing errors, data will be omitted. The default.
	"""
	deny
}
